{
  "id": "CVE-2025-21915",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-04-01T16:15:22.117",
  "lastModified": "2025-04-01T20:26:01.990",
  "vulnStatus": "Undergoing Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ncdx: Fix possible UAF error in driver_override_show()\n\nFixed a possible UAF problem in driver_override_show() in drivers/cdx/cdx.c\n\nThis function driver_override_show() is part of DEVICE_ATTR_RW, which\nincludes both driver_override_show() and driver_override_store().\nThese functions can be executed concurrently in sysfs.\n\nThe driver_override_store() function uses driver_set_override() to\nupdate the driver_override value, and driver_set_override() internally\nlocks the device (device_lock(dev)). If driver_override_show() reads\ncdx_dev->driver_override without locking, it could potentially access\na freed pointer if driver_override_store() frees the string\nconcurrently. This could lead to printing a kernel address, which is a\nsecurity risk since DEVICE_ATTR can be read by all users.\n\nAdditionally, a similar pattern is used in drivers/amba/bus.c, as well\nas many other bus drivers, where device_lock() is taken in the show\nfunction, and it has been working without issues.\n\nThis potential bug was detected by our experimental static analysis\ntool, which analyzes locking APIs and paired functions to identify\ndata races and atomicity violations."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: cdx: Se corrige un posible error de UAF en driver_override_show() Se corrigi\u00f3 un posible problema de UAF en driver_override_show() en drivers/cdx/cdx.c Esta funci\u00f3n driver_override_show() es parte de DEVICE_ATTR_RW, que incluye tanto driver_override_show() como driver_override_store(). Estas funciones se pueden ejecutar simult\u00e1neamente en sysfs. La funci\u00f3n driver_override_store() usa driver_set_override() para actualizar el valor de driver_override, y driver_set_override() bloquea internamente el dispositivo (device_lock(dev)). Si driver_override_show() lee cdx_dev-&gt;driver_override sin bloquear, podr\u00eda acceder potencialmente a un puntero liberado si driver_override_store() libera la cadena simult\u00e1neamente. Esto podr\u00eda llevar a imprimir una direcci\u00f3n del kernel, lo cual es un riesgo de seguridad ya que DEVICE_ATTR puede ser le\u00eddo por todos los usuarios. Adem\u00e1s, se utiliza un patr\u00f3n similar en drivers/amba/bus.c, as\u00ed como en muchos otros controladores de bus, donde device_lock() se utiliza en la funci\u00f3n show y ha funcionado sin problemas. Este posible error fue detectado por nuestra herramienta experimental de an\u00e1lisis est\u00e1tico, que analiza las API de bloqueo y las funciones emparejadas para identificar carreras de datos y violaciones de atomicidad."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/0439d541aa8d3444ad41c39e39eb71acb57acde3",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/8473135f89c0949436a22adb05b8cece2fb3da91",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/91d44c1afc61a2fec37a9c7a3485368309391e0b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/d7b339bbc887bcfc1a5b620bfc70c6fbb8f733bf",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}