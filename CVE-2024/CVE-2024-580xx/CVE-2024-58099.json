{
  "id": "CVE-2024-58099",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-04-29T12:15:31.053",
  "lastModified": "2025-04-29T13:52:10.697",
  "vulnStatus": "Undergoing Analysis",
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nvmxnet3: Fix packet corruption in vmxnet3_xdp_xmit_frame\n\nAndrew and Nikolay reported connectivity issues with Cilium's service\nload-balancing in case of vmxnet3.\n\nIf a BPF program for native XDP adds an encapsulation header such as\nIPIP and transmits the packet out the same interface, then in case\nof vmxnet3 a corrupted packet is being sent and subsequently dropped\non the path.\n\nvmxnet3_xdp_xmit_frame() which is called e.g. via vmxnet3_run_xdp()\nthrough vmxnet3_xdp_xmit_back() calculates an incorrect DMA address:\n\n  page = virt_to_page(xdpf->data);\n  tbi->dma_addr = page_pool_get_dma_addr(page) +\n                  VMXNET3_XDP_HEADROOM;\n  dma_sync_single_for_device(&adapter->pdev->dev,\n                             tbi->dma_addr, buf_size,\n                             DMA_TO_DEVICE);\n\nThe above assumes a fixed offset (VMXNET3_XDP_HEADROOM), but the XDP\nBPF program could have moved xdp->data. While the passed buf_size is\ncorrect (xdpf->len), the dma_addr needs to have a dynamic offset which\ncan be calculated as xdpf->data - (void *)xdpf, that is, xdp->data -\nxdp->data_hard_start."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: vmxnet3: Se corrige la corrupci\u00f3n de paquetes en vmxnet3_xdp_xmit_frame. Andrew y Nikolay informaron sobre problemas de conectividad con el balanceo de carga del servicio de Cilium en el caso de vmxnet3. Si un programa BPF para XDP nativo a\u00f1ade un encabezado de encapsulaci\u00f3n como IPIP y transmite el paquete por la misma interfaz, en el caso de vmxnet3 se env\u00eda un paquete da\u00f1ado que posteriormente se descarta en la ruta. vmxnet3_xdp_xmit_frame(), que se llama, por ejemplo, mediante vmxnet3_run_xdp() a trav\u00e9s de vmxnet3_xdp_xmit_back(), calcula una direcci\u00f3n DMA incorrecta: page = virt_to_page(xdpf-&gt;data); tbi-&gt;dma_addr = page_pool_get_dma_addr(page) + VMXNET3_XDP_HEADROOM; dma_sync_single_for_device(&amp;adapter-&gt;pdev-&gt;dev, tbi-&gt;dma_addr, buf_size, DMA_TO_DEVICE); Lo anterior asume un desplazamiento fijo (VMXNET3_XDP_HEADROOM), pero el programa XDP BPF podr\u00eda haber movido xdp-&gt;data. Si bien el buf_size pasado es correcto (xdpf-&gt;len), dma_addr debe tener un desplazamiento din\u00e1mico que se puede calcular como xdpf-&gt;data - (void *)xdpf, es decir, xdp-&gt;data - xdp-&gt;data_hard_start."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/4678adf94da4a9e9683817b246b58ce15fb81782",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/59ba6cdadb9c26b606a365eb9c9b25eb2052622d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/f82eb34fb59a8fb96c19f4f492c20eb774140bb5",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}